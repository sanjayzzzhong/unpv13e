## Chapter 2

### TCP连接的整体过程

* 图示

  ![image-20200303161808179](/Users/sanjay/Documents/GitHub/STL/assets/image-20200303161808179.png)

* 过程解析：

  * 客户端使用`connect`函数主动发起连接，发送`SYN=J, MSS=536`，代表请求连接，客户端的滑动窗口大小为536个字节；此时服务端是采用`listen`函数监听，使用`accept`函数阻塞等待请求的到来。
  * 服务端接收到客户端的请求，返回`SYN = K, ACK = J + 1, MSS=1460`，代表服务端也发起请求连接，收到客户端的请求连接了，服务端的滑动窗口大小为1460个字节。
  * 客户端收到服务端的返回信息，此时`connect`函数便返回值了，如果成功返回0，失败返回-1；同时客户端会发送`ACK = K+1`给服务端，表示接收到服务端的请求，下一次要接受的开始序号为`K+1`。

  ---

  以上就是TCP三次握手的过程。

  * 连接建立以后，双方就可以发送和接收信息了。分别使用`read`和`write`来进行读、写操作。

  ---

  接下来是四次挥手，断开连接的过程。

  * 客户端主动关闭连接，发送`FIN = M`的请求；
  * 服务端接收到请求，`read()`函数返回0，表示没有东西可读了；同时发送确认消息`ACK = M + 1`回给客户端，表示我接收到你关闭连接的请求了。
  * 服务端这时候也传输完数据了，主动发起关闭连接请求，发送`FIN = N`给客户端，请求断开连接；
  * 客户端收到服务器请求，回复`ACK = N + 1`，表示我收到你的断开连接请求了。至此，TCP连接断开。



#### TIME_WAIT的必要性

在四次挥手断开连接的时候，我们可以发现客户端在回复服务端的断开连接后，还等了TIME_WAIT长才关闭连接。TIME_WAIT的时长一般为2MSL（maximum segment lifetime， MSL），其中MSL是任何IP数据报能够在因特网中存活的最长时间。

为什么需要2个MSL呢？理由如下：

1. 为了可靠地实现TCP全双工连接的终止；
2. 让老的重复分节在网络中消逝。

具体来说，第一点，假设客户端最后回复的ACK消息在传输过程中丢失了，服务端没有等到这个回复，就会再次发送FIN消息，此时2MSL可以保证客户端能够接收到服务端重新发来的FIN消息，从而再次发送确认信号。

第二个理由是，假设我们在add1的1500端口和add2的21端口有一个tcp连接，当我们关闭这个连接之后，又重新建立连接，如果不等待2MSL的话，老的重复连接还没消逝，就有可能被新的连接给接收到；而等待2MSL的话，请求和应答最多存活MSL秒也会被丢弃，这样就可以保证不会出现上述情况。